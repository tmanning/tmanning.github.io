{"componentChunkName":"component---src-templates-blog-post-js","path":"/zod-lambda-validation/","result":{"data":{"site":{"siteMetadata":{"title":"Tom Manning's blog"}},"markdownRemark":{"id":"b3dacb80-1b95-5fcb-bbf0-b7f3da513e49","excerpt":"It’s common for lambdas to be triggered via API Gateway, but SNS, SQS, etc will all feed lambdas with strings. When you’re writing lambdas that take in JSON…","html":"<p>It’s common for lambdas to be triggered via API Gateway, but SNS, SQS, etc will all feed lambdas with strings. When you’re writing lambdas that take in JSON string parameters, you’re going to want to validate the input and convert it into a first class statically-typed object as soon as possible - after all, that’s why we use typescript, right? Since typescript is a type-safe language (by definition), using real Typescript types is the way to go here. The best way to define your parameters is as first-class Types in Typescript, and then validate that the string you’ve been given matches the object type that you’ve defined. But how?</p>\n<p>The way we used to validate input like this was via JSON schemas - we would define a schema and use a JSON schema validator like <code class=\"language-text\">ajv</code>. Maybe we would wrap our lambda in some middleware that would take in the schema and the event, use Middy to do the validation, and have the middleware spit out a validated object. But would it be typed? No! Then we’d also have to define a Typescript Type or Typescript Interface with essentially the same information as was in the JSON schema, and cast the object to that type. This is not a great developer experience. </p>\n<p>[Zod Library]:<a href=\"https://github.com/colinhacks/zod\">zod-library</a> is a library designed to make this easy; it lets you define a schema using native Typescript types. You can then ask Zod to validate the input for you and convert it to a first-class Typescript object - the best part is that your IDE’s Intellisense can understand it!  Let’s look at an example.</p>\n<p>Say I have an API Gateway method defined like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> update<span class=\"token operator\">:</span><span class=\"token function-variable function\">AsyncProxyHandler</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> event <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> commandRequest<span class=\"token operator\">:</span><span class=\"token builtin\">unknown</span> <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The problem with this is that we aren’t validating the command object. It could be anything!  But then we’d also have to define a Typescript Type or Typescript Interface with essentially the same information. Or generate one from the other. This was not an ideal solution. Instead, we can use Zod to do both the validation <em>and</em> define the type. Like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> z <span class=\"token keyword\">from</span> <span class=\"token string\">'zod'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> commandRequest <span class=\"token operator\">=</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    deviceId<span class=\"token operator\">:</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    tenantId<span class=\"token operator\">:</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">CommandRequest</span> <span class=\"token operator\">=</span> z<span class=\"token punctuation\">.</span>infer<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> commandRequest<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> update<span class=\"token operator\">:</span><span class=\"token function-variable function\">AsyncProxyHandler</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> event <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> json<span class=\"token operator\">:</span><span class=\"token builtin\">unknown</span> <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> command <span class=\"token operator\">=</span> commandRequest<span class=\"token punctuation\">.</span><span class=\"token function\">safeParse</span><span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//command is of type CommandRequest</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>parsed<span class=\"token punctuation\">.</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>parsed<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> statusCode<span class=\"token operator\">:</span> <span class=\"token number\">500</span><span class=\"token punctuation\">,</span> body<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> message<span class=\"token operator\">:</span> parsed<span class=\"token punctuation\">.</span>error <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>statusCode<span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Here we used Zod’s <code class=\"language-text\">safeParse</code> function that doesn’t immediately throw an error if it finds an object doesn’t conform to the schema; instead, it returns an object containing the results of the parse attempt. If you just want a valid object of the right type or an exception can use zod’s <code class=\"language-text\">parse</code> method instead.</p>\n<p>But what if one of your object’s fields is optional? No problem: define it as such, like so: <code class=\"language-text\">deviceId: z.string().optional()</code>.</p>\n<p>This first example was pretty straight forward, but most real-world applications are not. How about a more interesting use case, where we can employ Zod’s discriminated union functionality.</p>\n<p>Let’s say, instead of an API Gateway event handler, you’re writing a handler for an SQS queue. This queue could see several different types of messages, and you want a validator that can handle all of them as first-class Typescript Types. For discussion purposes, let us imagine that your queue contains commands of different types: Create and Delete, which have mostly the same attributes but have a discriminator for the command string.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> baseCommand <span class=\"token operator\">=</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  deviceId<span class=\"token operator\">:</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  tenantId<span class=\"token operator\">:</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> updateCommand <span class=\"token operator\">=</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  commandType<span class=\"token operator\">:</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">literal</span><span class=\"token punctuation\">(</span><span class=\"token string\">'update'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>baseCommand<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">UpdateCommand</span> <span class=\"token operator\">=</span> z<span class=\"token punctuation\">.</span>infer<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> updateCommand<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> deleteCommand <span class=\"token operator\">=</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  commandType<span class=\"token operator\">:</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">literal</span><span class=\"token punctuation\">(</span><span class=\"token string\">'delete'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>baseCommand<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">DeleteCommand</span> <span class=\"token operator\">=</span> z<span class=\"token punctuation\">.</span>infer<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> deleteCommand<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//Now create a discriminated union of the two commands</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> command <span class=\"token operator\">=</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">union</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  updateCommand<span class=\"token punctuation\">,</span>\n  deleteCommand\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> Command <span class=\"token operator\">=</span> z<span class=\"token punctuation\">.</span>infer<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> command<span class=\"token operator\">></span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> execute<span class=\"token operator\">:</span> <span class=\"token function-variable function\">SQSHandler</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> event <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> commands <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>Records<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> json<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        json <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token constant\">LOG</span><span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Failed to parse message'</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">const</span> parsed <span class=\"token operator\">=</span> zodObject<span class=\"token punctuation\">.</span><span class=\"token function\">safeParse</span><span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>parsed<span class=\"token punctuation\">.</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>parsed<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> parsed<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Now you have a collection of objects that may be of type UpdateCommand or of type DeleteCommand</span></code></pre></div>\n<p>We’ve barely scratched the surface of what Zod is capable of, but I hope it’s sparked some possibilitied in your mind.</p>","frontmatter":{"title":"Validating typescript Lambda input with Zod","date":"February 17, 2021","description":null}},"previous":null,"next":null},"pageContext":{"id":"b3dacb80-1b95-5fcb-bbf0-b7f3da513e49","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["2841359383","916993862"]}